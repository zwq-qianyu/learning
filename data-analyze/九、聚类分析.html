
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <!-- common.css -->
      <style>* {-webkit-tap-highlight-color: rgba(0,0,0,0);}html {-webkit-text-size-adjust: none;}body {font-family: -apple-system, Helvetica, Arial, sans-serif;margin: 0;padding: 20px;color: #333;word-wrap: break-word;}h1, h2, h3, h4, h5, h6 {line-height: 1.1;}img {max-width: 100% !important;height: auto;}blockquote {margin: 0;padding: 0 15px;color: #777;border-left: 4px solid #ddd;}hr {background-color: #ddd;border: 0;height: 1px;margin: 15px 0;}code {font-family: Menlo, Consolas, 'Ubuntu Mono', Monaco, 'source-code-pro', monospace;line-height: 1.4;margin: 0;padding: 0.2em 0;font-size: 90%;background-color: rgba(0,0,0,0.04);border-radius: 3px;}pre > code {margin: 0;padding: 0;font-size: 100%;word-break: normal;background: transparent;border: 0;}ol {list-style-type: decimal;}ol ol, ul ol {list-style-type: lower-latin;}ol ol ol, ul ol ol, ul ul ol, ol ul ol {list-style-type: lower-roman;}table {border-spacing: 0;border-collapse: collapse;margin-top: 0;margin-bottom: 16px;}table th {font-weight: bold;}table th, table td {padding: 6px 13px;border: 1px solid #ddd;}table tr {border-top: 1px solid #ccc;}table tr:nth-child(even) {background-color: #f8f8f8;}input[type="checkbox"] {cursor: default;margin-right: 0.5em;font-size: 13px;}.task-list-item {list-style-type: none;}.task-list-item+.task-list-item {margin-top: 3px;}.task-list-item input {float: left;margin: 0.3em 1em 0.25em -1.6em;vertical-align: middle;}#tag-field {margin: 8px 2px 10px;}#tag-field .tag {display: inline-block;background: #cadff3;border-radius: 4px;padding: 1px 8px;color: black;font-size: 12px;margin-right: 10px;line-height: 1.4;}</style>
      <!-- ace-static.css -->
      <style>.ace_static_highlight {white-space: pre-wrap;}.ace_static_highlight .ace_gutter {width: 2em;text-align: right;padding: 0 3px 0 0;margin-right: 3px;}.ace_static_highlight.ace_show_gutter > .ace_line {padding-left: 2.6em;}.ace_static_highlight .ace_line {position: relative;}.ace_static_highlight .ace_gutter-cell {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;user-select: none;top: 0;bottom: 0;left: 0;position: absolute;}.ace_static_highlight .ace_gutter-cell:before {content: counter(ace_line, decimal);counter-increment: ace_line;}.ace_static_highlight {counter-reset: ace_line;}</style>
      <style>.ace-chrome .ace_gutter {background: #ebebeb;color: #333;overflow : hidden;}.ace-chrome .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-chrome {background-color: #FFFFFF;color: black;}.ace-chrome .ace_cursor {color: black;}.ace-chrome .ace_invisible {color: rgb(191, 191, 191);}.ace-chrome .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-chrome .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-chrome .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-chrome .ace_invalid {background-color: rgb(153, 0, 0);color: white;}.ace-chrome .ace_fold {}.ace-chrome .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-chrome .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-chrome .ace_support.ace_type,.ace-chrome .ace_support.ace_class.ace-chrome .ace_support.ace_other {color: rgb(109, 121, 222);}.ace-chrome .ace_variable.ace_parameter {font-style:italic;color:#FD971F;}.ace-chrome .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-chrome .ace_comment {color: #236e24;}.ace-chrome .ace_comment.ace_doc {color: #236e24;}.ace-chrome .ace_comment.ace_doc.ace_tag {color: #236e24;}.ace-chrome .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-chrome .ace_variable {color: rgb(49, 132, 149);}.ace-chrome .ace_xml-pe {color: rgb(104, 104, 91);}.ace-chrome .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-chrome .ace_heading {color: rgb(12, 7, 255);}.ace-chrome .ace_list {color:rgb(185, 6, 144);}.ace-chrome .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-chrome .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-chrome .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-chrome .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-chrome .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-chrome .ace_gutter-active-line {background-color : #dcdcdc;}.ace-chrome .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-chrome .ace_storage,.ace-chrome .ace_keyword,.ace-chrome .ace_meta.ace_tag {color: rgb(147, 15, 128);}.ace-chrome .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-chrome .ace_string {color: #1A1AA6;}.ace-chrome .ace_entity.ace_other.ace_attribute-name {color: #994409;}.ace-chrome .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}</style>
      <!-- export.css -->
      <style>
        body{margin:0 auto;max-width:800px;line-height:1.4}
        #nav{margin:5px 0 10px;font-size:15px}
        #titlearea{border-bottom:1px solid #ccc;font-size:17px;padding:10px 0;}
        #contentarea{font-size:15px;margin:16px 0}
        .cell{outline:0;min-height:20px;margin:5px 0;padding:5px 0;}
        .code-cell{font-family:Menlo,Consolas,'Ubuntu Mono',Monaco,'source-code-pro',monospace;font-size:12px;}
        .latex-cell{white-space:pre-wrap;}
      </style>
      <!-- User CSS -->
      <style> .text-cell {font-size: 15px;}.code-cell {font-size: 12px;}.markdown-cell {font-size: 15px;}.latex-cell {font-size: 15px;}</style>
    </head>
    <body>
      <div id="nav"><div>Next: <a href='八、分类与预测.html'>八、分类与预测</a>, Previous: <a href='十、分类预测挑战（挑战）.html'>十、分类预测挑战（挑战）</a>, Up: <a href='index.html'>Index</a></div></div>
      <div id="titlearea">
        <h2>九、聚类分析</h2>
      </div>
      <div id="contentarea"><div class="cell text-cell"><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">本实验为实验楼训练营课程 《Python 数据分析入门与进阶》的第六节，在该章节中我们将谈论数据分析过程中遇到的聚类问题。</p><h2 id="-" style="box-sizing: border-box; font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; line-height: 1.25; color: rgb(36, 41, 46); margin-top: 24px; margin-bottom: 16px; padding-bottom: 0.3em; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(234, 236, 239); font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">知识点</h2><ul style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; padding-left: 2em; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><li style="box-sizing: border-box;">聚类概念</li><li style="box-sizing: border-box; margin-top: 0.25em;">K 值选择</li><li style="box-sizing: border-box; margin-top: 0.25em;">K 均值聚类</li><li style="box-sizing: border-box; margin-top: 0.25em;">其他聚类方法</li></ul><h2 id="-" style="box-sizing: border-box; font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; line-height: 1.25; color: rgb(36, 41, 46); margin-top: 24px; margin-bottom: 16px; padding-bottom: 0.3em; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(234, 236, 239); font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">什么是聚类？</h2><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">聚类，也叫做聚类分析，它是一门对数据进行统计分析的方法。聚类过程中，我们依据对象的属性，将相似的对象归位一类。例如，下面这张图，我们可以明显感觉数据点可被聚为 4 类。这里，我们参考的聚类属性有颜色和对象间距。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><img src="resources/3AF4C3A2D1AB5ED6589D2C597B8253B7.jpg" alt="此处输入图片的描述" style="box-sizing: content-box; border: 0px none; vertical-align: middle; background-color: rgb(255, 255, 255); cursor: pointer;" width="669" height="519"></p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">从聚类的类型来讲，一般有结构性聚类、分散性聚类、密度聚类等。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">其中，结构性聚类是指，结构性聚类中，我们可以从上至下或者从下至上双向进行计算。从下至上是以单个对象开始，不断与周围相近的对象进行融合，最终将全部数据分成多种类别。而从上至下算法则恰恰相反，它先将全部数据当作一个整体，然后逐渐分小。在结构性聚类中，我们的重要依据为距离。一般情况下，我们会使用欧式距离，或者曼哈顿距离来测量两个对象之间的相似程度。与结构性聚类不同，分散性聚类会一次性确定所有类别。另外，密度聚类的主要特点为将测算距离改为计算密度。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">除此之外，聚类分析的算法和分类还很多。而我们这里主要是讨论一些基于距离进行聚类的方法。</p><h3 id="-" style="box-sizing: border-box; font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; line-height: 1.25; color: rgb(36, 41, 46); margin-top: 24px; margin-bottom: 16px; font-size: 1.25em; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">为什么要聚类？</h3><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">当我们拿到一些原始数据时，这些数据是没有任何规律可循的。聚类，就是发生数据之间内在联系的方法。举个形象一点的例子：动物园里有很多动物，在没有聚类的情况下，每一种动物都是单独的类别。如果我们统计每种动物特点，腿的数量、有无耳朵、皮毛颜色、有无尾巴等。最终，我们就可以使用聚类将所有的动物分成数个大类。除此之外，书籍聚类、文档聚类、房屋类型聚类等，都会使用到聚类算法。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">有可能你会在分类和聚类之间疑惑。一般来讲，在一个机器学习任务或者数据分析实例中，我们会先采用聚类算法对数据进行处理。使用聚类算法对历史数据处理之后，就可以人为的给每一种类别打上标签。而这些存在标签的数据，就可以被应用到下一步的分类学习中。简而言之、在执行聚类之前，我们的数据没有任何类别可言。但在执行分类之前，我们应该已经有了类别，才能对新数据进行分类。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">下面这张图，可能让你对分类和聚类理解的更加到位：</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><img src="resources/75F0BCE0A89A4B8F38949DB42DBB493F.jpg" alt="此处输入图片的描述" style="box-sizing: content-box; border: 0px none; vertical-align: middle; background-color: rgb(255, 255, 255); cursor: pointer;" width="1683" height="704"></p><h2 id="k-k-means-" style="box-sizing: border-box; font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; line-height: 1.25; color: rgb(36, 41, 46); margin-top: 24px; margin-bottom: 16px; padding-bottom: 0.3em; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(234, 236, 239); font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">K-均值（K-Means）聚类</h2><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">K-均值聚类是最常用的聚类方法之一。从它的名字来讲，K 代表最终将全部样本数据集和聚为 K 个类别。而「均值」代表在聚类的过程中，我们计算聚类中心点的特征向量时，需要采用求相邻样本点特征向量均值的方式进行。例如，我们将 X1=(x1, y1), X2=(x2, y2), X3=(x3, y3) 聚为一类时，中心点坐标 O(o1, o1) 为：o1 = (x1+x2+x3)/3, o2=(y1+y2+y3)/3。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">在一个标准的 k 均值聚类过程中，我们首先要人为确定 k 值的大小，也就是聚类的数量。然后，我们会使用一种叫Forgy的方法初始化聚类，Forgy 也就是随机地从数据集中选择 k 个观测作为初始的均值点。例如，下图中，我们定 k=3，然后随机选择 3 个数据点初始化聚类。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><img src="resources/9D5212E06747D203DB5A934A0619D8EE.jpg" alt="此处输入图片的描述" style="box-sizing: content-box; border: 0px none; vertical-align: middle; background-color: rgb(255, 255, 255); cursor: pointer;" width="698" height="544"></p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">然后，我们以这三个样本点（红色）为基准，将剩余的数据点按照与其距离最近的标准进行类别划分。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><img src="resources/016559D3C6AD04466EEC7EAB88B7C639.jpg" alt="此处输入图片的描述" style="box-sizing: content-box; border: 0px none; vertical-align: middle; background-color: rgb(255, 255, 255); cursor: pointer;" width="698" height="544"></p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">这样，就得到了通过绿色线条划分的 A, B, C 三个区域。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">接下来，我们求解各区域中数据点集的中心点, 这一步也就是更新。然后得到三个紫色中心点。重复上面的步骤，得到由黄色线条划分的 D, E, F 三个区域。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><img src="resources/E602F5ABAF48EE98F994C91327B2A680.jpg" alt="此处输入图片的描述" style="box-sizing: content-box; border: 0px none; vertical-align: middle; background-color: rgb(255, 255, 255); cursor: pointer;" width="698" height="544"></p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">重复上面的步骤，直到三个区域的中心点变化非常小或没有变化时，终止迭代。最终，就将全部数据划分为 3 了类别。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">k 均值的迭代过程非常简单，但是非常有效。</p><h3 id="k-" style="box-sizing: border-box; font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; line-height: 1.25; color: rgb(36, 41, 46); margin-top: 24px; margin-bottom: 16px; font-size: 1.25em; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">K 值选择</h3><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">看完上面的示例，你应该对聚类的过程比较清晰了。简而言之，完成一项聚类任务分为三步：</p><ul style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; padding-left: 2em; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><li style="box-sizing: border-box;">第一步：选择聚类数量，也就是 K 值的大小。</li><li style="box-sizing: border-box; margin-top: 0.25em;">第二步：实施聚类算法，k-均值等。</li><li style="box-sizing: border-box; margin-top: 0.25em;">第三步：对聚类结果进行人工标注和分析。</li></ul><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">接下来，我们就来讨论一下如何选择&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">k</code>&nbsp;值。我们要相信，<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">k</code>&nbsp;值的大小并不是一拍脑袋就随便选一个。一个数据集该聚为多少个类，应该有一个比较合理的选择机制。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">当我们在使用 K-Means 聚类时，我们一般通过计算<span style="box-sizing: border-box; font-weight: 600;">轮廓系数</span>，来确定 k 值的大小。轮廓系数（Silhouette Coefficient），是聚类效果好坏的一种评价方式。轮廓系数结合内聚度（Cohesion）和分离度（Separation）两种因素，可以用来在相同原始数据的基础上用来评价不同算法、或者算法不同运行方式对聚类结果所产生的影响。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">对于某一点&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">i</code>，我们用&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">a(i)</code>&nbsp;表示&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">i</code>&nbsp;距离同类中其它点之间的距离的平均值，而&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">b(i)</code>&nbsp;表示&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">i</code>到所有非同类点的平均距离，然后取最小值。于是，<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">i</code>&nbsp;的轮廓系数计算如下：</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><img src="resources/A45E07EE03AC5DFEE37561781F54AC6F.png" alt="此处输入图片的描述" style="box-sizing: content-box; border: 0px none; vertical-align: middle; background-color: rgb(255, 255, 255); cursor: pointer;" width="1578" height="222"></p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">然后，我们计算数据集中所有点的轮廓系数，最终以平均值作为当前聚类的整体轮廓系数。整体轮廓系数介于&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">[-1,1]</code>&nbsp;，越趋近于 1 代表聚类的效果越好。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">scikit-learn 中，<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">sklearn.metrics.silhouette_score()</code>&nbsp;方法可以用来计算所聚类数据集的轮廓系数。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">接下来，我们就举一个例子来计算聚类过程中的轮廓系数，这里我们使用&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">three_class_data.csv</code>&nbsp;数据集用于演示，你<span style="box-sizing: border-box; font-weight: 600;">需要先下载该文件</span>：</p><pre style="box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; overflow-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;"><code class="hljs bash" style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; padding: 0.5em; color: rgb(248, 248, 242); background-color: rgb(35, 36, 31); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap; word-break: break-all; display: block; overflow-x: auto;">wget http:<span class="hljs-regexp" style="box-sizing: border-box; color: rgb(174, 129, 255);">//</span>labfile.oss.aliyuncs.com<span class="hljs-regexp" style="box-sizing: border-box; color: rgb(174, 129, 255);">/courses/</span><span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">764</span><span class="hljs-regexp" style="box-sizing: border-box; color: rgb(174, 129, 255);">/three_class_data.csv</span>
</code></pre><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">轮廓系数计算如下：</p><pre style="box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; overflow-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;"><code class="hljs python" style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; padding: 0.5em; color: rgb(248, 248, 242); background-color: rgb(35, 36, 31); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap; word-break: break-all; display: block; overflow-x: auto;">from sklearn.cluster <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">import</span> k_means
from sklearn.metrics <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">import</span> silhouette_score
from matplotlib <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">import</span> pyplot <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">as</span> plt
<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">import</span> pandas <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">as</span> pd

# 导入数据
<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span> = pd.read_csv(<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"three_class_data.csv"</span>, header=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">0</span>)

x = <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"x"</span>, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"y"</span>]]

# 建立模型
score = []

# 依次计算 <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">2</span> 到 <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">12</span> 类的轮廓系数
<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">for</span> i <span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">in</span> range(<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">10</span>):
    model = k_means(x, n_clusters=i + <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">2</span>)
    score.append(silhouette_score(x, model[<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>]))

plt.subplot(<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">2</span>, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>)
plt.scatter(<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'x'</span>], <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'y'</span>])

plt.subplot(<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">2</span>, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">2</span>)
plt.plot(range(<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">2</span>, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">12</span>, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>), score)
plt.show()
</code></pre><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">我们可以看到，下方左图为原数据集散点图。而右图是依次计算 2，3，……，12 类的轮廓系数折线图。右图明显看到，当k取3 时，轮廓系数最大。也就是说，推荐我们将原数据集聚为 3 类。这也印证了我们肉眼的观测结果。</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><img src="resources/446069C885FED0EB1794F98AB49080C0.jpg" alt="此处输入图片的描述" style="box-sizing: content-box; border: 0px none; vertical-align: middle; background-color: rgb(255, 255, 255); cursor: pointer;" width="1920" height="1041"></p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">其实，我们在计算轮廓系数时，已经用到了 k 均值算法，将数据集从 2 类依次变化到 12 类。我们将 k 均值算法选择 k=3 时的聚类结果绘制出来。</p><pre style="box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; overflow-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;"><code class="hljs " style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; padding: 0.5em; color: rgb(248, 248, 242); background-color: rgb(35, 36, 31); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap; word-break: break-all; display: block; overflow-x: auto;">from sklearn.cluster <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">import</span> k_means
from matplotlib <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">import</span> pyplot <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">as</span> plt
<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">import</span> pandas <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">as</span> pd

# 导入数据
<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span> = pd.read_csv(<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"three_class_data.csv"</span>, header=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">0</span>)

x = <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"x"</span>, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"y"</span>]]

# 建立模型
model = k_means(x, n_clusters=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">3</span>)

# 绘图
plt.scatter(<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'x'</span>], <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'y'</span>], c=model[<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>])
plt.show()
</code></pre><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><img src="resources/E2F74A028C3E13BB40C734DCBE0479C4.png" alt="此处输入图片的描述" style="box-sizing: content-box; border: 0px none; vertical-align: middle; background-color: rgb(255, 255, 255); cursor: pointer;" width="725" height="500"></p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">同样，我们可以绘制出k-均值聚类的决策边界。</p><pre style="box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; overflow-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;"><code class="hljs python" style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; padding: 0.5em; color: rgb(248, 248, 242); background-color: rgb(35, 36, 31); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap; word-break: break-all; display: block; overflow-x: auto;">
from sklearn.cluster <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">import</span> KMeans
from matplotlib <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">import</span> pyplot <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">as</span> plt
<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">import</span> pandas <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">as</span> pd
<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">import</span> numpy <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">as</span> np

# 导入数据
<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span> = pd.read_csv(<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"three_class_data.csv"</span>, header=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">0</span>)

x = <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"x"</span>, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"y"</span>]]

# 建立模型
model = KMeans(n_clusters=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">3</span>)
model.fit(x)

# 计算聚类过程中的决策边界
x_min, x_max = <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'x'</span>].min() - <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>, <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'x'</span>].max() + <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>
y_min, y_max = <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'y'</span>].min() - <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>, <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'y'</span>].max() + <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>
xx, yy = np.meshgrid(np.arange(x_min, x_max, .<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">01</span>), np.arange(y_min, y_max, .<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">01</span>))

result = model.predict(np.c_[xx.ravel(), yy.ravel()])

# 将决策边界绘制绘制出来
result = result.reshape(xx.shape)

plt.contourf(xx, yy, result, cmap=plt.cm.Greens)

plt.scatter(<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'x'</span>], <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">data</span>[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'y'</span>], c=model.labels_, s=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">15</span>)

# 绘制聚类中心点
center = model.cluster_centers_
plt.scatter(center[:, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">0</span>], center[:, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>], marker=<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'p'</span>, linewidths=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">2</span>, <span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">color</span>=<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'b'</span>, edgecolors=<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'w'</span>, zorder=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">20</span>)
plt.show()

</code></pre><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><img src="resources/A36DDADC087F8230041B173F56B1E5C6.png" alt="此处输入图片的描述" style="box-sizing: content-box; border: 0px none; vertical-align: middle; background-color: rgb(255, 255, 255); cursor: pointer;" width="833" height="600"></p><h2 id="-" style="box-sizing: border-box; font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; line-height: 1.25; color: rgb(36, 41, 46); margin-top: 24px; margin-bottom: 16px; padding-bottom: 0.3em; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(234, 236, 239); font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">其他聚类算法</h2><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">除了我们会经常用到的 K-均值聚类算法，Scikit-learn 还为我们提供了一些常见的聚类算法。</p><ul style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; padding-left: 2em; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><li style="box-sizing: border-box;"><p style="box-sizing: border-box; margin: 16px 0px;"><span style="box-sizing: border-box; font-weight: 600;">Mini Batch K-Means</span>&nbsp;Mini Batch K-Means 整体上和 K-Means 很相似，它是 K-Means 的一个变种形式。与 K-Means 不同的地方在于，其每次从全部数据集中抽样小数据集进行迭代。Mini Batch K-Means 算法在不对聚类效果造成较大影响的前提下，大大缩短了计算时间。</p></li><li style="box-sizing: border-box; margin-top: 0.25em;"><p style="box-sizing: border-box; margin: 16px 0px;"><span style="box-sizing: border-box; font-weight: 600;">Affinity Propagation</span>&nbsp;Affinity Propagation 又被称为亲和传播聚类。Affinity Propagation 是基于数据点进行消息传递的理念设计的。与 K-Means 等聚类算法不同的地方在于，亲和传播聚类不需要提前确定聚类的数量，即 K 值。但是运行效率较低。</p></li><li style="box-sizing: border-box; margin-top: 0.25em;"><p style="box-sizing: border-box; margin: 16px 0px;"><span style="box-sizing: border-box; font-weight: 600;">Mean Shift</span>&nbsp;MeanShift 又被称为均值漂移聚类。Mean Shift 聚类的目的是找出最密集的区域， 同样也是一个迭代过程。在聚类过程中，首先算出初始中心点的偏移均值，将该点移动到此偏移均值，然后以此为新的起始点，继续移动，直到满足最终的条件。Mean Shift 也引入了核函数，用于改善聚类效果。除此之外，Mean Shift 在图像分割，视频跟踪等领域也有较好的应用。</p></li><li style="box-sizing: border-box; margin-top: 0.25em;"><p style="box-sizing: border-box; margin: 16px 0px;"><span style="box-sizing: border-box; font-weight: 600;">Spectral Clustering</span>&nbsp;Spectral Clustering 又被称为谱聚类。谱聚类同样也是一种比较常见的聚类方法，它是从图论中演化而来的。谱聚类一开始将特征空间中的点用边连接起来。其中，两个点距离越远，那么边所对应的权值越低。同样，距离越近，那么边对应的权值越高。最后，通过对所有特征点组成的网络进行切分，让切分后的子图互相连接的边权重之和尽可能的低，而各子图内部边组成的权值和经可能高，从而达到聚类的效果。谱聚类的好处是能够识别任意形状的样本空间，并且可以得到全局最优解。</p></li><li style="box-sizing: border-box; margin-top: 0.25em;"><p style="box-sizing: border-box; margin: 16px 0px;"><span style="box-sizing: border-box; font-weight: 600;">Agglomerative Clustering</span>&nbsp;Agglomerative Clustering 又被称为层次聚类。层次聚类算法是将所有的样本点自下而上合并组成一棵树的过程，它不再产生单一聚类，而是产生一个聚类层次。层次聚类通过计算各样本数据之间的距离来确定它们的相似性关系，一般情况下，距离越小九代表相似度越高。最后，将相似度越高的样本归为一类，依次迭代，直到生成一棵树。由于层次聚类涉及到循环计算，所以时间复杂度比较高，运行速度较慢。</p></li><li style="box-sizing: border-box; margin-top: 0.25em;"><p style="box-sizing: border-box; margin: 16px 0px;"><span style="box-sizing: border-box; font-weight: 600;">Birch</span>&nbsp;Birch 是英文 Balanced Iterative Reducing and Clustering Using Hierarchies 的简称，它的中文译名为「基于层次方法的平衡迭代规约和聚类」，名字实在太长。Birch 引入了聚类特征树（CF树），先通过其他的聚类方法将其聚类成小的簇，然后再在簇间采用 CF 树对簇聚类。Birch 的优点是，只需要单次扫描数据集即可完成聚类，运行速度较快，特别适合大数据集。</p></li><li style="box-sizing: border-box; margin-top: 0.25em;"><p style="box-sizing: border-box; margin: 16px 0px;"><span style="box-sizing: border-box; font-weight: 600;">DBSCAN</span>&nbsp;DBSCAN 是英文 Density-based spatial clustering of applications with noise 的简称，它的中文译名为「基于空间密度与噪声应用的聚类方法」，名字同样很长。DBSCAN 基于密度概念，要求聚类空间中的一定区域内所包含的样本数目不小于某一给定阈值。算法运行速度快，且能够有效处理特征空间中存在的噪声点。但是对于密度分布不均匀的样本集合，DBSCAN 的表现较差。</p></li></ul><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">接下来，我们利用上面的数据集对 8 种不同的聚类方法，来一次简单的横向对比。</p><pre style="box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; overflow-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;"><code class="hljs python" style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; padding: 0.5em; color: rgb(248, 248, 242); background-color: rgb(35, 36, 31); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap; word-break: break-all; display: block; overflow-x: auto;"><span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">from</span> sklearn import cluster
<span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">from</span> matplotlib import pyplot <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">as</span> plt
import pandas <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">as</span> pd
import numpy <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">as</span> np
import <span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">time</span>

<span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 导入数据</span>
data = pd.read_csv(<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"three_class_data.csv"</span>, header=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">0</span>)

x = data[[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"x"</span>, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"y"</span>]]

<span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 对聚类方法依次命名</span>
cluster_names = [<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'KMeans'</span>, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'MiniBatchKMeans'</span>, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'AffinityPropagation'</span>, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'MeanShift'</span>, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'SpectralClustering'</span>, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'AgglomerativeClustering'</span>, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'Birch'</span>, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'DBSCAN'</span>]

<span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 确定聚类方法相应参数</span>
cluster_estimators = [
    cluster.KMeans(n_clusters=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">3</span>),
    cluster.MiniBatchKMeans(n_clusters=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">3</span>),
    cluster.AffinityPropagation(),
    cluster.MeanShift(),
    cluster.SpectralClustering(n_clusters=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">3</span>),
    cluster.AgglomerativeClustering(n_clusters=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">3</span>),
    cluster.Birch(n_clusters=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">3</span>),
    cluster.DBSCAN()
]

<span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 为绘制子图准备</span>
plot_num = <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>

<span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 依次运行不同的聚类方法</span>
<span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">for</span> name, model <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">in</span> zip(cluster_names, cluster_estimators):

    tic = <span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">time</span>.<span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">time</span>()

    <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 建立模型</span>
    model.fit(x)

    <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 绘制子图</span>
    plt.subplot(<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">2</span>, <span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">len</span>(cluster_estimators) / <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">2</span>, plot_num)

    <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 计算聚类过程中的决策边界</span>
    x_min, x_max = data[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'x'</span>].<span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">min</span>() - <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>, data[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'x'</span>].<span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">max</span>() + <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>
    y_min, y_max = data[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'y'</span>].<span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">min</span>() - <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>, data[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'y'</span>].<span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">max</span>() + <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>
    xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">.01</span>), np.arange(y_min, y_max, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">.01</span>))

    <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">if</span> hasattr(model, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'predict'</span>):
        <span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">result</span> = model.predict(np.c_[xx.ravel(), yy.ravel()])

        <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 将决策边界绘制绘制出来</span>
        <span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">result</span> = <span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">result</span>.reshape(xx.shape)

        plt.contourf(xx, yy, <span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">result</span>, cmap=plt.cm.Greens)

    plt.scatter(data[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'x'</span>], data[<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'y'</span>], c=model.labels_, s=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">15</span>)

    <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 判断方法中是否由 cluster_centers_ 聚类中心参数，并执行不同的命令</span>
    <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114);">if</span> hasattr(model, <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'cluster_centers_'</span>):
        center = model.cluster_centers_
        plt.scatter(center[:, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">0</span>], center[:, <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>], marker=<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'p'</span>, linewidths=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">2</span>, color=<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'b'</span>, edgecolors=<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">'w'</span>, zorder=<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">20</span>)

    <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 计算算法运行时间</span>
    toc = <span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">time</span>.<span class="hljs-built_in" style="box-sizing: border-box; color: rgb(230, 219, 116);">time</span>()
    cluster_time = (toc - tic)*<span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1000</span>

    <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94);"># 绘图</span>
    plt.title(str(name) + <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">", "</span> + str(int(cluster_time)) + <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116);">"ms"</span>)
    plot_num += <span class="hljs-number" style="box-sizing: border-box; color: rgb(174, 129, 255);">1</span>

plt.show()

</code></pre><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">结果如下：</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><img src="resources/1D199CFC5C23053D9459F882443136AB.png" alt="此处输入图片的描述" style="box-sizing: content-box; border: 0px none; vertical-align: middle; background-color: rgb(255, 255, 255); cursor: pointer;" width="1382" height="689"></p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">我们可以看出，结果比较理想的有：<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">KMeans, MiniBatchKMeans, MeanShift, SpectralClustering, AgglomerativeClustering</code>。而&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">Birch</code>&nbsp;和&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">DBSCAN</code>&nbsp;在默认参数下只得到一个有效类别，<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">AffinityPropagation</code>&nbsp;却得到了太多的类别。从聚类用时来看，<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; word-break: break-all;">AgglomerativeClustering</code>&nbsp;聚类效果不错，且用时较短。</p><h3 id="-" style="box-sizing: border-box; font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; line-height: 1.25; color: rgb(36, 41, 46); margin-top: 24px; margin-bottom: 16px; font-size: 1.25em; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">聚类算法选择</h3><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">面对上面的对比结果，并不是某几个算法不好，而是每一种方法适用的情况都各不相同。下面，我们就简单地说明一下，聚类算法的选择步骤：</p><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><span style="box-sizing: border-box; font-weight: 600;">1.</span>&nbsp;如果已知 K 值，即聚类的数量：</p><ul style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; padding-left: 2em; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><li style="box-sizing: border-box;">样本数量 &lt; 1 万，首选 Kmeans，效果不好再选择 SpectralClustering。</li><li style="box-sizing: border-box; margin-top: 0.25em;">样本数量 &gt; 1 万，首选 MiniBatch Kmeans。</li></ul><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><span style="box-sizing: border-box; font-weight: 600;">2.</span>&nbsp;如果 K 值未知：</p><ul style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; padding-left: 2em; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);"><li style="box-sizing: border-box;">样本数量 &lt; 1 万，首选 MeanShift。</li><li style="box-sizing: border-box; margin-top: 0.25em;">样本数量 &gt; 1 万，依靠经验灵活应对了。</li></ul><h2 id="-" style="box-sizing: border-box; font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; line-height: 1.25; color: rgb(36, 41, 46); margin-top: 24px; margin-bottom: 16px; padding-bottom: 0.3em; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(234, 236, 239); font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">实验总结</h2><p style="box-sizing: border-box; margin: 0px 0px 16px; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(249, 249, 249);">本节课我们了解了什么是聚类，以及常见的聚类算法。其中，我们详细的介绍了 K-均值聚类方法，对它的聚类流程进行了全面解析。为了帮助初学者，课程中涉及的示例都较为简单，课后可以使用 scikit-learn 中提供的 iris 数据集或者 digits 手写字体识别数据集进一步加深对聚类的理解和认识。</p><div><br></div></div></div>
      <script>document.body.onkeyup = function(e) {
if (e.keyCode === 39) window.location.href = '八、分类与预测.html';
if (e.keyCode === 37) window.location.href = '十、分类预测挑战（挑战）.html';
}</script>
    </body>
    </html>
  